{"version":3,"sources":["typing.ts","covering.ts","drawing.ts","littlebird.ts","main.ts"],"names":[],"mappings":"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","file":"main.08f50033.js","sourceRoot":"../src","sourcesContent":["export class Vector {\n\n    x: number;\n    y: number;\n\n    constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n    }\n\n    scale(alpha: number): Vector {\n        return new Vector(this.x * alpha, this.y * alpha);\n    }\n\n    add(vector: Vector): Vector {\n        return new Vector(this.x + vector.x, this.y + vector.y);\n    }\n\n    subtract(vector: Vector): Vector {\n        return new Vector(this.x - vector.x, this.y - vector.y);\n    }\n\n    copy(): Vector {\n        return new Vector(this.x, this.y);\n    }\n\n    dot(v: Vector) {\n        return this.x * v.x + this.y * v.y;\n    }\n\n    norm() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n\n    round() {\n        return new Vector(Math.round(this.x), Math.round(this.y));\n    }\n\n}\n\nexport class Basis {\n    v: Vector;\n    w: Vector;\n\n    constructor(v: Vector, w: Vector) {\n        this.v = v;\n        this.w = w;\n    }\n\n    /**\n     * Return coefficients when expressing 2D vector as weighted sum of basis vectors.\n     * From:\n     * https://math.stackexchange.com/questions/148199/equation-for-non-orthogonal-projection-of-a-point-onto-two-vectors-representing\n     * alpha = (z-component of w cross z) / (z-component of w cross v)\n     * beta = (z-component of v cross z) / (z-component of v cross w)\n     * @param z Arbitrary 2D vector\n     */\n    toCoefficients(z: Vector): Vector {\n        let alpha = (this.w.x * z.y - this.w.y * z.x) / (this.w.x * this.v.y - this.w.y * this.v.x);\n        let beta = (this.v.x * z.y - this.v.y * z.x) / (this.v.x * this.w.y - this.v.y * this.w.x);\n        return new Vector(alpha, beta);\n    }\n\n    /**\n     * Return weighted sum of basis vectors \n     * @param z weights / coefficients (often integer)\n     */\n    fromCoefficients(z: Vector): Vector {\n        return this.v.scale(z.x).add(this.w.scale(z.y));\n    }\n\n    scale(t: number): Basis {\n        return new Basis(this.v.scale(t), this.w.scale(t));\n    }\n\n}\n\nexport class Rectangle {\n\n    topLeft: Vector;\n    bottomRight: Vector;\n\n    constructor(topLeft: Vector, bottomRight: Vector) {\n        this.topLeft = topLeft;\n        this.bottomRight = bottomRight;\n    }\n\n    corners(): Array<Vector> {\n        return [this.topLeft, new Vector(this.topLeft.x, this.bottomRight.y), this.bottomRight, new Vector(this.bottomRight.x, this.topLeft.y)];\n    }\n\n    center(): Vector {\n        return new Vector((this.topLeft.x + this.bottomRight.x) / 2, (this.topLeft.y + this.bottomRight.y) / 2);\n    }\n\n    translate(v: Vector): Rectangle {\n        return new Rectangle(this.topLeft.add(v), this.bottomRight.add(v));\n    }\n\n    transform(transformation: Transformation): Rectangle {\n        return new Rectangle(\n            transformation.transform(this.topLeft),\n            transformation.transform(this.bottomRight),\n        ); \n    }\n\n    /**\n     * Return true if another rectangle overlaps with this one.\n     * @param r Another rectangle\n     */\n    overlaps(r: Rectangle): boolean {\n        let overlapsX = (this.topLeft.x <= r.bottomRight.x) && (r.topLeft.x <= this.bottomRight.x);\n        let overlapsY = (this.topLeft.y <= r.bottomRight.y) && (r.topLeft.y <= this.bottomRight.y);\n        return overlapsX && overlapsY;\n    }\n\n    width(): number {\n        return this.bottomRight.x - this.topLeft.x;\n    }\n\n    height(): number {\n        return this.bottomRight.y - this.topLeft.y;\n    }\n\n}\n\n\nexport class Transformation {\n\n    translation: Vector;\n    scaling: number;\n\n    constructor(translation: Vector, scaling: number) {\n        this.translation = translation;\n        this.scaling = scaling;\n    }\n\n    transform(v: Vector) {\n        return v.scale(this.scaling).add(this.translation);\n    }\n\n}\n\nexport interface Unit {\n    draw: (ctx: CanvasRenderingContext2D) => void;\n    boundingBox: Rectangle;\n}\n","import { Vector, Basis, Rectangle } from \"./typing\";\n\n\n/**\n * Return coefficients in basis for all vectors by which to shift boundingBox to cover canvas.\n */\nexport function generateCovering(boundingBox: Rectangle, basis: Basis, canvas: Rectangle): Array<Vector> {\n\n    function translatedBoundingBoxOverlapsCanvas(coefficients: Vector) {\n        return boundingBox.translate(basis.fromCoefficients(coefficients)).overlaps(canvas);\n    }\n\n    const origin = new Vector(0, 0);\n    const leftMost = searchLeft(origin, translatedBoundingBoxOverlapsCanvas);\n    const rightMost = searchRight(origin, translatedBoundingBoxOverlapsCanvas);\n    const centerRange = new HorizontalRange(leftMost, rightMost);\n\n    let coefficients: Array<Vector> = [...centerRange];\n    for (const horizontalRange of createSearchVertical(centerRange, translatedBoundingBoxOverlapsCanvas, true)) {\n        coefficients = coefficients.concat([...horizontalRange]);\n    }\n    for (const horizontalRange of createSearchVertical(centerRange, translatedBoundingBoxOverlapsCanvas, false)) {\n        coefficients = coefficients.concat([...horizontalRange]);\n    }\n\n    return coefficients;\n\n}\n\n\nfunction searchHorizontal(initial: Vector, valid: (v: Vector) => boolean, ascending = true): Vector {\n    let v = initial.copy();\n    const dx = ascending ? 1 : -1;\n    v.x += dx;\n    while (valid(v)) {\n        v.x += dx;\n    }\n    return new Vector(v.x - dx, v.y);\n}\n\n\nconst searchLeft = (initial: Vector, valid: (v: Vector) => boolean) => searchHorizontal(initial, valid, false);\nconst searchRight = (initial: Vector, valid: (v: Vector) => boolean) => searchHorizontal(initial, valid, true);\n\n\nclass HorizontalRange {\n    left: Vector;\n    right: Vector;\n\n    constructor(left: Vector, right: Vector) {\n        if (left.y !== right.y) {\n            throw new Error(`y values should be equal (${left.y} != ${right.y})`);\n        }\n        if (left.x > right.x) {\n            throw new Error(`vectors should be ordered by x coordinate (${left.x} > ${right.x})`);\n        }\n        this.left = left;\n        this.right = right;\n    }\n\n    *[Symbol.iterator]() {\n        for (let x = this.left.x; x <= this.right.x; x++) {\n            yield new Vector(x, this.left.y);\n        }\n    }\n\n}\n\n\nfunction* createSearchVertical(initial: HorizontalRange, valid: (v: Vector) => boolean, ascending = true) {\n\n    function searchVertical(current: HorizontalRange): HorizontalRange | null {\n        const y = current.left.y + (ascending ? 1 : -1);\n        const left = new Vector(current.left.x, y);\n        const right = new Vector(current.right.x, y);\n        let leftMost = searchLeft(left, valid);\n        let rightMost = searchRight(right, valid);\n\n        while (!valid(leftMost) && leftMost.x < rightMost.x) {\n            leftMost.x++;\n        }\n        while (!valid(rightMost) && leftMost.x < rightMost.x) {\n            rightMost.x--;\n        }\n        if (valid(leftMost)) {\n            return new HorizontalRange(leftMost, rightMost);\n        } else {\n            return null;\n        }\n    }\n\n    let horizontalRange = searchVertical(initial);\n    while (horizontalRange !== null) {\n        yield horizontalRange;\n        horizontalRange = searchVertical(horizontalRange);\n    }\n\n}\n","import { Basis, Rectangle, Transformation, Unit } from \"./typing\";\nimport { generateCovering } from \"./covering\";\n\nexport type Drawable = (ctx: CanvasRenderingContext2D, transformation: Transformation) => void;\n\n\n/**\n * Unit repeated across a 2D grid.\n */\nexport function createTiling(unitOriginal: Unit, basisOriginal: Basis, canvas: Rectangle): Drawable {\n\n    return (ctx, transformation) => {\n\n        let unit = transformUnit(unitOriginal, transformation);\n        let basis = basisOriginal.scale(transformation.scaling);\n\n        // Translate unit by vector in span of basis to move bounding box close to canvas center.\n        let difference = canvas.center().subtract(unit.boundingBox.center());\n        const roundedDifference = basis.fromCoefficients(basis.toCoefficients(difference).round());\n        unit = transformUnit(unit, new Transformation(roundedDifference, 1));\n\n        let debug = false;\n        if (debug) {\n            drawRectangle(ctx, unit.boundingBox);\n        }\n\n        for (const coefficients of generateCovering(unit.boundingBox, basis, canvas)) {\n            const t = basis.fromCoefficients(coefficients);\n            transformDraw(unit.draw, new Transformation(t, 1))(ctx);\n        }\n    }\n\n}\n\n\nexport function withFill(draw: Drawable, fillStyle?: string): Drawable {\n\n    return (ctx, transformation) => {\n        ctx.beginPath();\n        draw(ctx, transformation);\n        if (fillStyle) {\n            ctx.fillStyle = fillStyle;\n        }\n        ctx.fill();\n    }\n\n}\n\n\nexport function withModifyTransformation(draw: Drawable, modifyTransformation: (t: Transformation) => Transformation): Drawable {\n\n    return (ctx, transformation) => draw(ctx, modifyTransformation(transformation));\n\n}\n\n\nexport function joinDrawables(drawables: Drawable[]): Drawable {\n\n    return (ctx, transformation) => {\n        for (const drawable of drawables) {\n            drawable(ctx, transformation);\n        }\n    }\n\n}\n\n\nexport function drawBackground(canvas: Rectangle): Drawable {\n\n    return (ctx, _) => {\n        ctx.fillStyle = \"white\";\n        ctx.fillRect(canvas.topLeft.x, canvas.topLeft.y, canvas.width(), canvas.height());\n    }\n}\n\n\nfunction transformDraw(draw: (ctx: CanvasRenderingContext2D) => void, transformation: Transformation) {\n    return function (ctx: CanvasRenderingContext2D) {\n        ctx.save();\n        ctx.translate(transformation.translation.x, transformation.translation.y);\n        ctx.scale(transformation.scaling, transformation.scaling);\n        draw(ctx);\n        ctx.restore();\n    }\n}\n\n\nfunction transformUnit(unit: Unit, transformation: Transformation): Unit {\n    return {\n        draw: transformDraw(unit.draw, transformation),\n        boundingBox: unit.boundingBox.transform(transformation)\n    }\n}\n\n\nfunction drawRectangle(ctx: CanvasRenderingContext2D, rectangle: Rectangle, lineWidth = 5, strokeStyle = \"blue\") {\n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = strokeStyle;\n    ctx.rect(rectangle.topLeft.x, rectangle.topLeft.y, rectangle.width(), rectangle.height());\n    ctx.stroke();\n}\n","import { Vector, Basis, Rectangle, Transformation, Unit } from \"./typing\";\nimport { Drawable, createTiling, withFill, withModifyTransformation, joinDrawables, drawBackground } from \"./drawing\";\n\n\nconst sqrt3 = Math.sqrt(3);\n\n\nexport function createLittleBirdPattern(canvas: Rectangle): Drawable {\n\n    const colours: { [key: string]: string } = {\n        \"black\": \"black\",\n        \"orange\": \"rgb(176, 93, 37)\",\n        \"green\": \"rgb(35, 98, 45)\",\n        \"blue\": \"rgb(81, 122, 184)\",\n    }\n\n    const colour_order = [\"black\", \"orange\", \"green\", \"blue\"];\n\n    const starTilingReference = createTiling(littleBirdStar, new Basis(new Vector(0, 12), new Vector(2 * sqrt3, 0)), canvas);\n    const wingTilingReference = createTiling(littleBirdWing, new Basis(new Vector(-sqrt3, 3), new Vector(8 * sqrt3, 0)), canvas);\n\n    let tilings: Drawable[] = [];\n\n    for (let i = 0; i < 4; i++) {\n        let starTiling = withFill(starTilingReference, colours[colour_order[i]]);\n        starTiling = withModifyTransformation(\n            starTiling,\n            (t) => new Transformation(\n                new Vector(t.translation.x + i * sqrt3 * t.scaling, t.translation.y + 3 * i * t.scaling), t.scaling,\n            )\n        );\n        tilings.push(starTiling);\n\n        let wingTiling = withFill(wingTilingReference, colours[colour_order[i]]);\n        wingTiling = withModifyTransformation(\n            wingTiling,\n            (t) => new Transformation(new Vector(t.translation.x + i * 2 * sqrt3 * t.scaling, t.translation.y), t.scaling)\n        );\n        tilings.push(wingTiling);\n    }\n\n    return joinDrawables([drawBackground(canvas), ...tilings]);\n\n}\n\n\nconst littleBirdStar: Unit = {\n    draw: function (ctx: CanvasRenderingContext2D) {\n        let r = sqrt3 - 1;\n\n        ctx.moveTo(r, 0);\n        ctx.save();\n        for (let i = 0; i < 6; i++) {\n            ctx.lineTo(r, 0);\n            ctx.lineTo(0.5 * r, 0.25 * r);\n            ctx.rotate(Math.PI / 3);\n        }\n        ctx.lineTo(r, 0);\n        ctx.restore();\n    },\n    boundingBox: new Rectangle(new Vector(-1, -1), new Vector(1, 1))\n}\n\n\nconst littleBirdWing: Unit = {\n    draw: function (ctx: CanvasRenderingContext2D) {\n        const r = sqrt3 - 1;\n\n        ctx.save();\n        ctx.translate(0, 2);\n        for (let i = 0; i < 3; i++) {\n            ctx.moveTo(0.5 * r, r * sqrt3 / 2);\n            ctx.arc(0.5 * sqrt3, 1.5, 1, 4 * Math.PI / 3, 3 * Math.PI / 2);\n            ctx.arc(sqrt3 / 2, -0.5, 1, Math.PI / 2, (11 / 6) * Math.PI, true);\n            ctx.arc(sqrt3 / 2, -1.5, 1, Math.PI / 6, (2 / 3) * Math.PI);\n            ctx.lineTo(r, 0);\n            ctx.lineTo(0.5 * r, r * sqrt3 / 2);\n            ctx.rotate((2 / 3) * Math.PI);\n        }\n\n        ctx.restore();\n    },\n    boundingBox: (function () {\n        let r = 3 * sqrt3 / 2;\n        return new Rectangle(new Vector(-r, -r + 2), new Vector(r, r + 2));\n    })()\n}\n","import { Vector, Rectangle, Transformation } from \"./typing\";\nimport { createLittleBirdPattern } from \"./littlebird\";\nimport { Drawable } from \"./drawing\";\n\nconst canvas = document.querySelector('canvas');\n\nif (canvas != null) {\n    const ctx = canvas.getContext('2d');\n    \n    if (ctx != null) {\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n\n        const canvasRectangle = new Rectangle(new Vector(0, 0), new Vector(canvas.width, canvas.height));\n        let pattern = createLittleBirdPattern(canvasRectangle);\n        let transformation = new Transformation(new Vector(600, 400), 40);\n\n        pattern(ctx, transformation);\n\n        addEventListenersKeyboard(document, ctx, pattern, transformation, canvasRectangle.center());\n        addEventListenersMouse(document, ctx, pattern, transformation);\n    }\n}\n\n\nfunction addEventListenersKeyboard(\n    document: Document, ctx: CanvasRenderingContext2D, pattern: Drawable, transformation: Transformation, canvasCenter: Vector\n) {\n\n    document.addEventListener('keydown', (event) => {\n\n        let shiftSpeed = 10\n\n        switch (event.code) {\n            case 'Minus':\n                zoom(transformation, canvasCenter, 0.98)\n                break;\n            case 'Equal':\n                zoom(transformation, canvasCenter, 1.02)\n                break;\n            case 'ArrowRight':\n                transformation.translation.x += shiftSpeed;\n                break;\n            case 'ArrowLeft':\n                transformation.translation.x -= shiftSpeed;\n                break;\n            case 'ArrowUp':\n                transformation.translation.y -= shiftSpeed;\n                break;\n            case 'ArrowDown':\n                transformation.translation.y += shiftSpeed;\n                break;\n        }\n\n        pattern(ctx, transformation);\n\n    }, false);\n\n}\n\n\nfunction addEventListenersMouse(document: Document, ctx: CanvasRenderingContext2D, pattern: Drawable, transformation: Transformation) {\n\n    let mouseX = 0;\n    let mouseY = 0;\n    let mouseDown = false;\n\n\n    document.addEventListener('mousedown', e => {\n        mouseX = e.offsetX;\n        mouseY = e.offsetY;\n        mouseDown = true;\n    });\n\n\n    document.addEventListener('mousemove', e => {\n        if (mouseDown) {\n            transformation.translation.x += e.offsetX - mouseX;\n            transformation.translation.y += e.offsetY - mouseY;\n            pattern(ctx, transformation);\n            mouseX = e.offsetX;\n            mouseY = e.offsetY;\n        }\n    });\n\n    document.addEventListener('mouseup', e => {\n        if (mouseDown) {\n            transformation.translation.x += e.offsetX - mouseX;\n            transformation.translation.y += e.offsetY - mouseY;\n            pattern(ctx, transformation);\n            mouseDown = false;\n        }\n    });\n\n    document.addEventListener('wheel', e => {\n        if (e.deltaY === 0) {\n            return;\n        }\n        let factor = e.deltaY > 0 ? 0.98 : 1.02;\n        zoom(transformation, new Vector(e.offsetX, e.offsetY), factor)\n        pattern(ctx, transformation);\n    });\n}\n\n\nfunction zoom(transformation: Transformation, center: Vector, ratio: number) {\n    transformation.scaling *= ratio;\n    transformation.translation = transformation.translation.scale(ratio).subtract(center.scale(ratio - 1));\n}"]}